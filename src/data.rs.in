use crexp_client_proto::messages as client;
use std::fmt;
use std::ops::{Deref,DerefMut};
use hex_slice::AsHex;

#[derive(Debug,PartialEq,Eq,PartialOrd,Ord,Hash,Clone,Copy,Default, Serialize, Deserialize)]
pub struct Seqno(u64);
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash,Clone)]
pub struct Buf(ByteBuf);

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum Operation {
    Set(String),
    Get
}

#[derive(Debug, Serialize, Deserialize)]
pub enum OpResp {
    Ok(Epoch, Seqno, Option<Buf>),
    HelloIWant(Timestamp<WallT>, Seqno),
    Err(Epoch, Seqno, String),
}

impl Into<client::ClientResp> for OpResp {
    fn into(self) -> client::ClientResp {
        match self {
	    OpResp::Ok(_, seqno, None) => client::ClientResp::Ok(seqno.into()),
	    OpResp::Ok(_, seqno, Some(val)) => {
		warn!("Ignored response val @{:?}: {:?}", seqno, val);
		client::ClientResp::Ok(seqno.into())
	    },
	    OpResp::HelloIWant(_, _) => unreachable!(),
	    OpResp::Err(_, seqno, message) => client::ClientResp::Err(seqno.into(), message),
	}
    }
}

impl Into<client::Buf> for Buf {
    fn into(self) -> client::Buf {
	let vec : Vec<u8> = self.0.into();
	vec.into()
    }
}

impl From<client::Buf> for Buf {
    fn from(item: client::Buf) -> Buf {
	let vec : Vec<u8> = item.into();
	From::from(vec)
    }
}

impl Deref for Buf {
    type Target = <ByteBuf as Deref>::Target;
    fn deref(&self) -> &Self::Target {
	&self.0
    }
}

impl DerefMut for Buf {
    // type Target = ByteBuf;
    fn deref_mut(&mut self) -> &mut Self::Target {
	&mut self.0
    }
}

impl fmt::Debug for Buf {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
	write!(fmt, "{:x}", (&*self.0).as_hex())
    }
}

impl Into<client::Seqno> for Seqno {
    fn into(self) -> client::Seqno {
	self.0.into()
    }
}

#[derive(Eq,PartialEq, Clone, Debug, Serialize, Deserialize)]
pub enum Role {
    Client,
    Upstream,
}

#[derive(Debug, Clone, PartialEq, Eq, Default, Serialize, Deserialize)]
pub struct NodeViewConfig {
    pub peer_addr: Option<String>,
    pub client_addr: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum PeerMsg {
    HelloDownstream(Timestamp<WallT>),
    Prepare (Seqno, Buf),
    CommitTo (Seqno),
}
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ReplicationMessage {
    pub epoch: Epoch,
    pub msg: PeerMsg,
}

#[cfg(test)]
mod test {
    use data::Operation;
    use quickcheck::{self, Arbitrary, Gen};

    impl Arbitrary for Operation {
        fn arbitrary<G: Gen>(g: &mut G) -> Operation {
            match u64::arbitrary(g) % 2 {
                0 => Operation::Set(format!("{:x}", u64::arbitrary(g))),
                1 => Operation::Get,
                _ => unimplemented!(),
            }
        }
        fn shrink(&self) -> Box<Iterator<Item = Self> + 'static> {
            match self {
                &Operation::Set(ref s) => Box::new(s.shrink().map(Operation::Set)),
                &Operation::Get => quickcheck::empty_shrinker(),
            }
        }
    }
}
