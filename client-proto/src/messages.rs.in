use std::fmt;
use serde::bytes::ByteBuf;
use serde::{de,ser};

#[derive(Debug,PartialEq,Eq,PartialOrd,Ord,Hash,Clone,Copy,Default, Serialize, Deserialize)]
pub struct Seqno(u64);
#[derive(PartialEq,Eq,PartialOrd,Ord,Hash,Clone)]
pub struct Buf(ByteBuf);

#[derive(Debug,PartialEq,Eq,PartialOrd,Ord,Hash,Clone, Serialize, Deserialize)]
pub enum ClientReq {
    Publish(Buf)
}
#[derive(Debug,PartialEq,Eq,PartialOrd,Ord,Hash,Clone, Serialize, Deserialize)]
pub enum ClientResp {
    Ok(Seqno, Option<Buf>),
    Err(Seqno, String),
}

impl Into<Vec<u8>> for Buf {
    fn into(self) -> Vec<u8> {
        self.0.into()
    }
}

impl From<Vec<u8>> for Buf {
    fn from(bytes: Vec<u8>) -> Self {
        Buf(From::from(bytes))
    }
}

impl ser::Serialize for Buf {
    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>
        where S: ser::Serializer
    {
        self.0.serialize(serializer)
    }
}

impl de::Deserialize for Buf {
    #[inline]
    fn deserialize<D>(deserializer: &mut D) -> Result<Buf, D::Error>
        where D: de::Deserializer
    {
        de::Deserialize::deserialize(deserializer).map(Buf)
    }
}

impl Into<u64> for Seqno {
    fn into(self) -> u64 {
        self.0.into()
    }
}

impl From<u64> for Seqno {
    fn from(bytes: u64) -> Self {
        Seqno(From::from(bytes))
    }
}

impl fmt::Debug for Buf {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
	use hex_slice::AsHex;
	write!(fmt, "{:x}", (&*self.0).as_hex())
    }
}

